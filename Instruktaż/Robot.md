# 2. **Robot.**

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_0.jpg>

### **Lista wymaganych materiałów.**

1. **Chassis Rectangle 2WD 2-kołowe podwozie robota z napędem** – 1 sztuka 
<p align="center">
<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_1.jpg width="30%" height="30%">
</p>
Przezroczysta platforma do budowy robota. W zestawie znajdują się dwa silniki prądu stałego z kołami o średnicy 65 mm. W części przedniej podporę stanowi metalowe koło obrotowe. Elementy podwozia są zrobione z akrylu, posiadają otwory montażowe pozwalające zamontować różnego rodzaju sensory czy kontrolery.

Zestaw zawiera:

* Platformę montażową
* Dwa koła z oponami o średnicy 65 mm 
* Dwa silniki prądu stałego z przekładniami
* Jedno metalowe koło obrotowe montowane przy pomocy dwóch śrub
* Metalowe oraz plastikowe podzespoły (śrubki, nakrętki, itp.)
* Włącznik
* Koszyk na baterie (4 x AA) ze przewodami ze zdjętą izolacją

Warto tutaj dodać, że jeśli zdecydujesz się na zakup danego podwozia, to nie musisz już martwić się o silniki oraz koła, ponieważ są zawarte w tym zestawie. Natomiast nadal powinieneś zakupić podany w tej liście koszyk na baterie.

Przykładowy link do sklepu:

[https://botland.com.pl/pl/podwozia-robotow/7283-chassis-rectangle-2wd-2-kolowe-podwozie-robota-z-napedem.html](https://botland.com.pl/pl/podwozia-robotow/7283-chassis-rectangle-2wd-2-kolowe-podwozie-robota-z-napedem.html)

[https://abc-rc.pl/product-pol-7656-Podwozie-robota-2WD-RT-5-210mm-2-silniki-podwozie-Arduino.html](https://abc-rc.pl/product-pol-7656-Podwozie-robota-2WD-RT-5-210mm-2-silniki-podwozie-Arduino.html) 

2. **Silnik DC z przekładnią 1:48** – 2 sztuki (zawarte w zestawie z podwoziem)
<p align="center">
<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_2.jpg width="30%" height="30%">
</p>
Unikalna jednostka napędowa do Twojego robota. Silnik prądu stałego z przekładnią 1:48 zapewni wspaniałe osiągi dla Twojego robota. Dwustronna oś pozwala zamontować koło z oponą z dowolnej strony. 

3. **Koło plastikowe z oponą 65/25 mm** – 2 sztuki (zawarte w zestawie z podwoziem)
<p align="center">
<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_3.jpg width="30%" height="30%">
</p>
Doskonała ochrona przed aquaplaningiem. Krótka droga hamowania. Bardzo dobra przyczepność na zakrętach. Niski poziom hałasu przez cały okres eksploatacji opony.

4. **Moduł dwukanałowego sterownika silników z L298N**– 1 sztuka
<p align="center">
<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_4.jpg width="30%" height="30%">
</p>
Umożliwia on sterowanie jednocześnie dwóch silników DC lub jednego silnika krokowego. Kontroler ten pozwala ustawić stałą (pełną) prędkość obrotu kół, lub kontrolować ją sygnałem PWM.

Przykładowy link do sklepu:

[https://abc-rc.pl/product-pol-6196-Modul-sterownika-L298N-do-silnikow-DC-i-krokowych-Arduino.html](https://abc-rc.pl/product-pol-6196-Modul-sterownika-L298N-do-silnikow-DC-i-krokowych-Arduino.html) 

[https://nettigo.pl/products/modul-dwukanalowego-sterownika-silnikow-z-l298n](https://nettigo.pl/products/modul-dwukanalowego-sterownika-silnikow-z-l298n)

5. **Moduł WiFi NodeMCU V3 LoLin ESP-12E(Arduino)** – 1 sztuka
<p align="center">
<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_5.jpg width="30%" height="30%">
</p>
Przykładowy link do sklepu:

[https://nettigo.pl/products/modul-wifi-nodemcu-v3-lolin-esp-12e](https://nettigo.pl/products/modul-wifi-nodemcu-v3-lolin-esp-12e)

[https://botland.com.pl/pl/moduly-wifi/8241-modul-wifi-esp8266-nodemcu-v3.html](https://botland.com.pl/pl/moduly-wifi/8241-modul-wifi-esp8266-nodemcu-v3.html) 

6. **Kondensator 100uF 16V lub więcej** - 1 sztuka
<p align="center">
<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_6.png width="30%" height="30%">
</p>
Przykładowy link do sklepu:

[https://botland.com.pl/pl/kondensatory-elektrolityczne-tht/898-kondensator-elektrolityczny-100uf35v-6x12mm-105c-tht-10szt.html](https://botland.com.pl/pl/kondensatory-elektrolityczne-tht/898-kondensator-elektrolityczny-100uf35v-6x12mm-105c-tht-10szt.html)

[https://nettigo.pl/products/zestaw-5-kondensatorow-elektrolitycznych-100-f-35v](https://nettigo.pl/products/zestaw-5-kondensatorow-elektrolitycznych-100-f-35v) 

7. **Dwupozycyjny przełącznik MTS-102** – 1 sztuka
<p align="center">
<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_7.jpg width="30%" height="30%">
</p>
Przełącznik dźwigniowy, dwupozycyjny, jednosekcyjny, MTS-1.

Dane techniczne:

Rodzaj napięcia AC/DC Obciążenie do 3A przy 250V Obciążenie do 6A przy 125V Wysokość: 33mm Średnica otworu montażowego: 6mm

Jeśli dostaniemy koszyk na ogniwa z włącznikiem, wtedy ta część jest nie potrzebna

Przykładowy link do sklepu:

[https://nettigo.pl/products/dwupozycyjny-przelacznik-mts-102](https://nettigo.pl/products/dwupozycyjny-przelacznik-mts-102)

[https://botland.com.pl/pl/przelaczniki-z-dzwignia/2478-przelacznik-dzwigniowy-on-on-250v3a.html](https://botland.com.pl/pl/przelaczniki-z-dzwignia/2478-przelacznik-dzwigniowy-on-on-250v3a.html)

8. **Koszyk na dwa ogniwa 18650 2S**– 1 sztuka
<p align="center">
<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_8.jpg width="30%" height="30%">
</p>
Łączy w szereg dwa ogniwa 18650. Daje to od ~7.0 do 8.4 V w zależności od naładowania ogniw. Długi 30-centymetrowy kabel daje się ładnie układać. 

Przykładowy link do sklepu:
[https://botland.com.pl/pl/koszyki-na-baterie/5240-koszyk-na-2-baterie-typu-18650.html](https://botland.com.pl/pl/koszyki-na-baterie/5240-koszyk-na-2-baterie-typu-18650.html) 

[https://abc-rc.pl/product-pol-8528-Koszyk-na-akumulator-2x-18650-3-7V-Li-Ion-koszyczek-na-baterie-ogniwo-z-przewodami.html]
(https://abc-rc.pl/product-pol-8528-Koszyk-na-akumulator-2x-18650-3-7V-Li-Ion-koszyczek-na-baterie-ogniwo-z-przewodami.html) 

Koszyk z włącznikiem:
[https://abc-rc.pl/product-pol-12801-Koszyk-na-akumulator-2x-18650-z-wylacznikiem-koszyczek-z-pokrywa-i-przewodami.html](https://abc-rc.pl/product-pol-12801-Koszyk-na-akumulator-2x-18650-z-wylacznikiem-koszyczek-z-pokrywa-i-przewodami.html) 

9. **Stabilizator liniowy 3.3V  min. 0.8A** – 1 sztuka
<p align="center">
<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_9.jpg width="30%" height="30%">
</p>
Przykładowy link do sklepu:

[https://nettigo.pl/products/stabilizator-liniowy-3-3v-0-8a](https://nettigo.pl/products/stabilizator-liniowy-3-3v-0-8a)

[https://botland.com.pl/pl/regulatory-napiecia/7685-stabilizator-ldo-33v-ld1117v33-tht-to220.html](https://botland.com.pl/pl/regulatory-napiecia/7685-stabilizator-ldo-33v-ld1117v33-tht-to220.html) 

### **Budowa Robota**

Będąc odpowiednio przygotowanym, możemy przejść do budowy naszego robota. 

**Przygotowanie silników**

Sprawdzamy czy w silnikach mamy zlutowane kabelki, jeśli są to przejdź do kolejnego kroku.

Zdejmujemy najpierw mały kawałek izolacji na kabelkach - około 1 do 2mm, możesz do tego użyć na przykład noża do tapet. Lekko natnij izolację i pociągnij, powinna bez problemu zejść.

Następnie potrzebujemy rozgrzać lutownicę, jeżeli posiadasz zwykłą kolbową - dotknij grotu cyną, jeśli będzie się topić to lutownica jest wystarczająco nagrzana, jeśli jednak posiadasz lutownicę z możliwością regulacji temperatury - ustaw ją w okolicach 400-450 stopni.

Na blaszkę w silniku nakładamy odrobinę cyny.

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_10.png>

Odsłonięty kabel przykładamy do blaszki silnika - kolor kabelka jest obecnie nieistotny, polaryzację możemy zmienić później w kodzie robota.

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_11.png> 

Przykładamy rozgrzaną lutownicę do odsłoniętego kabelka i nakładamy cynę tak, aby rozgrzała cynę na blaszce i abyśmy mogli przełożyć kabelek przez dziurkę i pokryć go cyną. Oczywiście nie powinieneś ruszać kabelkiem w trakcie lutowania. Po krótkiej chwili lut zastygnie i połączenie będzie gotowe. Powtarzamy tą czynność dla reszty kabelków.

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_12.png>

Jeśli korzystasz z koszyka na ogniwa, które podaliśmy w liście części, prawdopodobnie nie będzie musiał lutować kabelków. Jeśli jednak koszyk nie miałby kabli lub miałbyś inny koszyk na baterie, powtórz powyższe czynności.

**Lutowanie włącznika**

Istotnym jest jeszcze dolutowanie przycisku włączenia/wyłączenia, bez tego nasz robot się nie uruchomi. Łapiemy za koszyk na ogniwo i ucinamy czarny kabelek mniej więcej w połowie. Teraz musimy jeszcze zdjąć kawałek izolacji na końcu kabelka od koszyka oraz z obu stron na uciętym kawałku kabelka. 

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_13.png>

Następnie przechodzimy do lutowania.

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_14.png>

Kabelek, który został odcięty lutujemy do blaszki w  miejscu, w którym znajduje się "I" na przycisku, a w miejscu “O” powinniśmy dolutować czarny kabel, który wychodzi od koszyka na ogniwa. “I” oznacza włączony, a “O” wyłączony.

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_15.png>

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_16.png>

Po zakończonym lutowaniu dobrze jest wgrać kod do robota, tak dla wygody. Opis jak to zrobić znajdziesz w kolejnym dziale nazwanym "Kod do robota".

**Przygotowanie podwozia**

Musimy odpowiednio wywiercić otwory w podwoziu, tak aby móc zamontować części w odpowiednich miejscach. Przykładamy koszyki od akumulatorów i zaznaczamy markerem miejsca, w których następnie wiercimy otwory. 

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_17.png>
<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_18.png>

Do wiercenia używamy wiertła 3mm. 

Czynności powtarzamy dla kontrolera DC. 

Na koniec odklejamy jeszcze folię zabezpieczającą podwozie.

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_19.png><img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_20.png>

**Montaż części**

Łapiemy za śrubokręt krzyżakowy oraz śrubki i przykręcamy do podwozia silniki w uchwytach montażowych.

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_21.png><img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_22.png>

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_23.png>

Następnie montujemy części, dla których wywierciliśmy otwory w punkcie powyżej, czyli kontroler DC oraz koszyk na ogniwa.

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_24.png><img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_25.png>

Przykręcamy również koło obrotowe, dla którego zrobiono miejsca na przodzie podwozia.

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_26.png><img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_27.png>

Po zamontowaniu wszystkich części, polecamy użyć pistoletu na klej i zakleić koło obrotowe. Dzięki temu, robot będzie bardziej stabilny podczas jazdy. Uważaj tylko żeby przyklejone koło było ustawione prosto, inaczej robot będzie niepotrzebnie skręcał w trakcie jazdy.

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_28.png>

**Połączenie części**

Zaczynamy od połączenia kabli silników do wejść na kontrolerze DC - są to skręcane, skrajne podwójne wejścia. To jak podłączysz silniki nie ma w tym momencie znaczenia. Po skończeniu robota przetestuj go i zamień w razie potrzeby kable od silników.

Następnie czas podpiąć zasilanie. Jeśli korzystasz z płytki drukowanej, na płytce masz wyprowadzone odpowiednie piny do zasilania kontrolera DC, a zasilanie Node’a idzie prosto z regulatora napięcia do odpowiednich wejść. Jeśli używasz płytki uniwersalnej, wlutuj regulator napięcia w płytkę oraz połącz ze sobą odpowiednie piny regulatora i Node’a (Regulator -> NodeMCU)

* Output -> 3.3V
* GND -> GND

Pamiętaj aby do wejścia Input regulatora podpiąć + od zasilania.
Bezpośrednio z zasilania, podłącz się kabelkami do wejść 12V i GND w DC Controlerze (Zasilanie -> DC Controller)

* 12V -> 12V
* GND -> GND

Na płytce mamy dwie sekcje po 3 piny, odpowiadające pinom D1,D2,D3 oraz D5,D6,D7 znajdującym się w NodeMCU.

Podłączamy je zgodnie z opisem poniżej (NodeMCU -> DC Controller)

* D1 -> IN4
* D2 -> IN3
* D3 -> ENA
* D5 -> IN1
* D6 -> IN2
* D7 -> ENB

Oczywiście możesz piny podłączyć w inny, np. bardziej uporządkowany sposób. Pamiętaj jednak aby nanieść zmiany w kodzie. Pamiętaj również, że piny w NodeMCU nie są numerowane w kodzie tak, jak jest to opisane na płytce. Skorzystaj np. z tego schematu by sprawdzić piny:

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_30.png >

### **Kod do robota**

Cały, gotowy do wgrania kod do robota znajdziesz pod tym linkiem:

[Kod do robota](https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Kod%20-%20robot/Robot.ino)

**Instalacja kodu**

Pobierz plik z kodem i otwórz go w Arduino IDE. Następnie podłącz robota do swojego komputera. Mając otwarty plik z kodem w IDE oraz podłączonego robota, wciśnij ikonę strzałki w programie i poczekaj aż kod zostanie wgrany do robota.

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaRobot/image_29.png>

A jeśli interesuje Cię co się w tym kodzie znajduje, poniżej opiszę kod krok po kroku.

**Opis kodu**

Zacznijmy od dołączenia odpowiedniej biblioteki, która odpowiedzialna będzie za obsługę ESP8266.
```
#include <ESP8266WiFi.h>
```
Następnie definiujemy nazwę sieci, jeśli zmienna APSSID, w której umieszczamy nazwę naszej sieci nie jest zdefiniowana, to deklarujemy ją warunkowo.
```
#ifndef APSSID 
#define APSSID "Robot"
#endif
```
I powtarzamy czynność dla zmiennej PORT.
```
#ifndef PORT 
#define PORT 12345
#endif
```
Przechodzimy do zdefiniowania zmiennej odpowiedzialnej za przechowywanie serwera.
```
WiFiServer server(PORT); 
const char *ssid = APSSID;
```
Na koniec definiujemy zmienne odpowiadające za piny do silników, prędkość, czas jazdy pojazdu i diodę LED.
```
int IN1=12;   
int IN2=14;   
int IN3=4;    
int IN4=5;    
int ENA=0;    
int ENB=13;   
int multi_=1;  
int time_=250;
int led=2;
```
Musimy teraz napisać funkcje odpowiedzialne za sterowanie robotem w obu trybach, więc  przejdziemy do napisania pierwszej z funkcji odpowiedzialnej za sterowanie robotem. Funkcja będzie przyjmować argumenty odpowiedzialne za stany silników, mnożnik prędkości oraz czas poruszania.
```
void drive(int I1, int I2, int I3, int I4, int multi, int t){
```
Następnie zapisujemy ustawienia stanów silników.
```
digitalWrite(IN1,I1);
digitalWrite(IN2,I2);
digitalWrite(IN3,I3);
digitalWrite(IN4,I4);
```
I przechodzimy do napisania pętli odpowiedzialnej za płynne rozpędzanie naszego pojazdu.
```
Serial.println("Akceleracja:");
for(int i = 0; i < 1024; i += multi){
```
Ustawiamy prędkości silników.
```
analogWrite(ENA,i);
analogWrite(ENB,i);
Serial.print(i);
Serial.print("...");
delay(1);
}
```
Skoro już rozpędziliśmy naszego robota, musimy teraz napisać pętlę odpowiedzialną za jego płynne hamowanie.
```
delay(t);
Serial.println("Hamowanie:");
for(int i = 1024; i > 0; i -= multi){
```
Tak jak przy rozpędzaniu, ustawiamy prędkości silników również przy hamowaniu i kończymy jedną z funkcji odpowiedzialną za sterowanie.
```
analogWrite(ENA,i);
analogWrite(ENB,i);
Serial.print(i);
Serial.print("...");
delay(1);
 }
}
```
Przejdźmy teraz do napisania drugiej z funkcji, tym razem odpowiedzialnej za swobodne sterowanie pojazdem. Funkcja będzie przyjmować argumenty odpowiedzialne za stany silników.
```
void freeDrive(int I1, int I2, int I3, int I4){
```
Ustawiamy prędkość na 100%, tak aby mieć jak najwięcej zabawy podczas korzystania z pojazdu w danym trybie.
```
analogWrite(ENA,1024);
analogWrite(ENB,1024);
```
Zapisujemy ustawienia stanów silników i zamykamy drugą z funkcji odpowiedzialnych za sterowanie.
```
digitalWrite(IN1,I1);
digitalWrite(IN2,I2);
digitalWrite(IN3,I4);
digitalWrite(IN4,I4); 
}
```
Następnie piszemy małą funkcję odpowiedzialną za zapisywanie ustawień użytkownika dotyczących prędkości oraz czasu poruszania pojazdu.
```
void setVars(int multi, int t){ 
  multi_ = multi;
  time_ = t;
}
```
Potrzebna będzie jeszcze funkcja z ustawieniami pinów oraz wifi.
```
void setup(){
```
Ustawiamy wcześniej zdefiniowanym pinom tryb wyjścia.
```
pinMode(IN1,OUTPUT); 
pinMode(IN2,OUTPUT); 
pinMode(IN3,OUTPUT); 
pinMode(IN4,OUTPUT); 
pinMode(ENA,OUTPUT); 
pinMode(ENB,OUTPUT);
```
Następnie ustawiamy tryb WiFi jako tryb dostępu (Access Point) i dla pewności wykonujemy rozłączenie z siecią. Tak na wypadek gdyby został wykonany soft reset.
```
WiFi.mode(WIFI_STA); 
WiFi.disconnect();
delay(100);
```
Rozpoczynamy sesje dla serial monitora.
```
Serial.begin(115200); 
Serial.println();
Serial.print("Konfiguracja AP...");
```
Ustawiamy adres ip, bramę domyślną oraz maskę robota i następnie zapisujemy konfigurację sieci. Warto tutaj dodać, że oktety w programie dla adresu ip, bramy oraz maski są oddzielone przecinkiem, a nie kropką tak jak się domyślnie przyjęło.
```
IPAddress ip(192,168,1,200);
IPAddress gateway(192,168,1,254);
IPAddress subnet(255,255,255,0);
WiFi.softAPConfig(ip, gateway, subnet);
```
Następnie włączamy tryb dostępu (Access Point)
```
WiFi.softAP(ssid);
IPAddress myIP = WiFi.softAPIP();
```
oraz pobieramy adres IP i wyświetlamy go w monitorze.
```
Serial.print("AP IP: ");
Serial.println(myIP);
```
Rozpoczynamy sesje serwera TCP.
```
server.begin();
```
Na końcu ustawień dla pewności zatrzymujemy silniki i kończymy funkcję z ustawieniami.
```
digitalWrite(IN1,LOW);
digitalWrite(IN2,LOW); 
digitalWrite(IN3,LOW); 
digitalWrite(IN4,LOW); 
analogWrite(ENA,0);
analogWrite(ENB,0);
}
```
Została ostatnia z funkcji. Mianowicie funkcja odpowiedzialna za sprawdzanie czy klient ( w tym wypadku mata) jest podłączony, odczytywanie komend a następnie ich wykonanie.
```
void loop(){
```
Na początku zapisujemy informacje o połączonym kliencie.
```
WiFiClient client = server.available();
```
Następnie sprawdzamy warunkowo czy zmienna z klientem istnieje oraz czy sam klient jest już podłączony.
```
if (client){
 if(client.connected()){
  Serial.println("Client Connected"); 
 }
```
Tworzymy pętle, która będzie się wykonywać, jeśli klient jest połączony z robotem oraz dopóki liczba połączonych użytkowników będzie większa niż zero.
```
while(client.connected()){
while(client.available()>0){
```
Teraz trzeba odczytać sekwencję znaków przesyłanych przez użytkownika (matę). Sekwencja ta kończyć się będzie znakiem nowej lini.
```
String line = client.readStringUntil('\n');
```
Następnie tworzymy tablice znaków (char), konwertujemy wcześniej odczytaną sekwencję do pojedynczych znaków i zapisujemy je w utworzonej tablicy znaków.
```
char cmd[line.length()+1]; 
line.toCharArray(cmd, line.length()+1);
```
Przechodzimy do pętli, która będzie wykonywała komendy znajdujące się w tablicy.
```
for(int i = 0; i < line.length()+1; i ++){
```
Teraz musimy sprawdzać komendy switchem i następnie wykonać je odpowiednimi case’ami. Każdy przypadek (case) zawiera funkcję "drive" lub “freeDrive”, która zostanie wykonana z argumentami dla konkretnej komendy.
```
switch(cmd[i]){
  case 'u': 
    drive(HIGH, LOW, HIGH, LOW, multi_, time_);
    break;
  case 'd':
    drive(LOW, HIGH, LOW, HIGH, multi_, time_);
    break;
  case 'r':
    drive(LOW, HIGH, HIGH, LOW, multi_, time_);
    break;
  case 'l':
    drive(HIGH, LOW, LOW, HIGH, multi_, time_);
    break;
  case 'z':
    freeDrive(HIGH, LOW, HIGH, LOW);
    break;
  case 'x':
    freeDrive(LOW, HIGH, LOW, HIGH);
    break;
  case 'c':
    freeDrive(LOW, HIGH, HIGH, LOW);
    break;
  case 'v':
    freeDrive(HIGH, LOW, LOW, HIGH);
    break;
```
Na końcu switcha dodajemy jeszcze przypadek, w którym użytkownik podaje nieznane komendy i wykonujemy w niej funkcję drive z argumentami zatrzymującymi pojazd.
```
default:
  drive(LOW,LOW,LOW,LOW,1,0);
  break;
 }
}
```
Odczytujemy jeszcze komendy podane przez serial monitor, gdy aktywna jest jego sesja.
```
while(Serial.available()>0){
   client.write(Serial.read());
  }
 }
}
```
Na koniec zatrzymujemy połączenie z użytkownikiem.
```
client.stop();
  Serial.println("Client disconnected");    
  }
}
```
